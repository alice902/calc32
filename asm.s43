#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
                                              
        RSEG    DATA16_C                ; Constant R/only data segment (Flash).       

LCD_table                               ; Tablica kodĂłw LCD
        DB 0xB7                         ; 0
        DB 0x12                         ; 1
        DB 0x8F                         ; 2
        DB 0x1F                         ; 3
        DB 0x3A                         ; 4
        DB 0x3D                         ; 5
        DB 0xBD                         ; 6
        DB 0x13                         ; 7
        DB 0xBF                         ; 8
        DB 0x3F                         ; 9
        
;--- WPROWADZENIE ARGUMENTĂ“W ----;        
arg1    DL -90000                            ; Generates 32bit constant.
arg2    DL 50                           ; Argumenty do wykonania operacji.

minus   DW 0x8000                       ; 1000 0000 0000 0000 w U2 liczba ujemna
err     equ 0xAD                        ; kod LCD dla liczby E

        RSEG DATA16_Z                   ; Initialized to 0 data segment (RAM).
   
result  DS32 1                          ; Allocates space for 32bit variable.
BCD_res DS32 1                          ; wynik, wynik w BCD i bufor LCD
LCD_buf DS8 7

        RSEG CODE                       ; place program in 'CODE' segment
        
init    MOV     #SFE(CSTACK), SP        ; set up stack

main    NOP                             ; main program
        MOV.W #WDTPW+WDTHOLD,&WDTCTL    ; Stop watchdog timer
        MOV.B #0xFD, &LCDACTL           ; Sets up LCDA register, MUX4 mode

        CLR R5                          ; Wyczyszczenie rejestrĂłw
        CLR R6                          ; Adres bufora LCD
        CLR R7                          ; LSW arg1
        CLR R8                          ; MSW arg1
        CLR R9                          ; LSW arg2
        CLR R10                         ; MSW arg2
        CLR R11                         ; Rejestry pomocnicze
        CLR R12                         ;
        CLR R13                         ; 
        
        MOV.W arg1+2, R8                ; Wpisanie argumentĂłw do rejestrĂłw
        MOV.W arg1, R7                  ; MSB arg1 do R8, LSB arg1 do R7
        MOV.W arg2+2, R10               ; MSB arg2 do R10
        MOV.W arg2, R9                  ; LSB arg2 do R9
        
;--- WYBOR OPERACJI ---;        
        ;CALL #addition
        ;CALL #substraction
        CALL #multiplication
        
addition                                ; dodawanie
        ADD.W R9, R7                    ; LSB + LSB
        ADDC.W R10, R8                  ; MSB + MSB z uzwglednieniem Carry
        JN set_minus_flag               ; Skocz do etykiety set_minus_flag jesli N=1
        JMP save_result                 ; Jak nie to skocz do save_result
        
substraction                            ; odejmowanie
        SUB.W R9, R7                    ; LSB - LSB
        SUBC.W R10, R8                  ; MSB - MSB z uwzglednieniem Carry
        JN set_minus_flag               ; Skocz do etykiety set_minus_flag jesli N=1
        JMP save_result                 ; Jak nie to skocz do save_result
        
multiplication
        BIT minus, R8                   ; Sprawdzenie czy arg1 < 0
        JN to_pos1                      ; Testowanie najstarszego bitu (znak w u2)
        JMP next                        ; Jesli arg1 dodatni sprawdz arg2
to_pos1 INV R8                          ; Jesli ujemny zamien na dodatni
        INV R7                          ; (odwroc bity i dodaj 1)
        INC R7
        MOV #1, R11                     ; Analogiczne sprawdzenie arg2
next    BIT minus, R10                   
        JN to_pos2
        JMP mltpl                       ; Jesli arg2 dodatni skocz do mltpl
to_pos2 INV R10				; Jesli nie analogicznie zamien na ujemna
        INV R9
        INC R9
        MOV #1, R12
mltpl   ;CMP #0x0001, R8                 ; Sprawdzenie czy argumenty sa 16bitowe
        ;JGE over                        ; Jesli arg1 wiekszy lub rowny 0xFFFF
        ;CMP #0x0001, R10		; to skocz do over
        ;JGE over			; Analogicznie z arg2
        MOV R9, R4                      ; Wpisanie arg2 do R9
        MOV #1, R5                      ; Wpisanie 1 do R5 (licznik petli)
        CLR R10				; Wyczysc rejestry R10 i R8
        ;CLR R8
        MOV.W R7, R9                    ; Wpisz arg1 do R9
        MOV.W R8, R10
loop    INC R5                          ; Inkrementacja R5
        ADD.W R9, R7                    ; LSW + LSW
        ADDC.W R10, R8                  ; MSW + MSW with Carry
        CMP R5,R4                       ; Porownanie R5 i R4. Jesli R4 = R5 to Z=1
        JNZ loop                        ; Jesli Z=0 skocz do loop
        CLRZ				; Jesli nie to wyczysc Z
        CMP R12, R11                    ; Wynik dodatni jesli 
        JEQ save_result                 ; Skocz do save result jesli R12=R11
        MOV.B #0x10,LCDM8               ; Jesli nie, zasygnalizuj minus                      
        MOV.W R7, result                ; Wpisz zawartosc rejestrow R7 i R8
        MOV.W R8, result+2              ; do BCD_result
        JMP BCD_conversion		; Skocz do BCD_conversion
        
set_minus_flag
        MOV.B #0x10,LCDM8 		; Zasygnalizowanie ujemnego wyniku
        
save_result
        MOV.W R7, result                ; Zapisywanie wyniku do result
        MOV.W R8, result+2		; (miejsce w pamieci)
        BIT minus, result+2             ; Sprawdzenie czy wynik < 0
        JN is_negative                  ; Jesli wynik < 0 (N=1) skocz do       
	JMP BCD_conversion		; is_negative, jesli nie do BCD_conv
is_negative 
        INV result+2                    ; Zamiana na liczbe dodatnia w U2 
        INV result                      ; (odwrĂłc bity i dodaj 1)
        INC result
        DADC result+2                   ; Dodaj Carry

BCD_conversion
        MOV #32, R5                     ; Wpisz 32 do rejestru R5 (licznik)
        CLR R8				; Czyszczenie rejestrow	
        CLR R9
shift   RLA result                      ; Rotate left
        RLC result+2                    ; Rotate left with Carry
        DADD R9, R9                     ; src, dst + C to dst (decimally) LSW
        DADD R8, R8			; MSW
        DEC R5                          ; Dekrementacja R15
        JNZ shift                       ; Skocz do shift jesli Z=0
        MOV.W R9, BCD_res		; Wpisanie R9 do BCD_res (LSW)
        MOV.W R8, BCD_res+2		; i R10 do BCD_res+2 (MSW)
        ; Na podstawie MSP 430 Mixed Signal Microcontroller Application Reports
        ; (page 559)
        
range   
        CMP #9999, BCD_res+2
        JC over
        JMP write_buffer
over    MOV.B #0xAD, LCDM1		; Zasygnalizowanie przekroczenia zakresu
        JMP end_programme 		; Skocz do end_programme

write_buffer
        MOV #0x000F, R7                 ; Ustawienie maski
        CLR R10                         ; Licznik petli dla maski                  
        MOV #LCD_buf,R6                 ; Wpisz adres LCD_buff do R6
loop_a  CLR R11
        CMP #4, R10			; Porownanie R10 z 4
        JEQ display			; Jesli jest rowne to skocz do display
        MOV BCD_res, R5                 ; Zapisz LSW BCD_res do R5
        MOV BCD_res+2, R8		; Zapisz MSW BCD_res do R8
        AND R7, R5			; maska AND LSW BCD_res
        AND R7, R8			; i MSW 
	CMP #0, R10			; Sprawdz czy R10=0
	JNE loop_b			; Jesli nie skocz do loop_b
	MOV.B R5,0(R6)			; Jesli tak zapisz zawartosc rejestru R5 
        MOV.B R8,4(R6)			; do komorki pod adresem 0+R6 (LSW LCD_buf)
	INC R6				; oraz R8 do 4+R6 (MSW LCD_buf)
	INC R10				; Inkrementacja R6 i R10
	RLAM.A #4,R7			; Przesun bitowo zawartoĹ›Ä‡ R7 w lewo 4x
	JMP loop_a			; Skocz do loop_a
loop_b  RRAM.A #4, R5			; Przesun bitowo zawartoĹ›Ä‡ R5 w prawo 4x
        RRAM.A #4, R8			; i analogiczne R8
        INC R11				; Inkrementacja R11
	CMP R11, R10			; Porownaj R11 i R10
	JNE loop_b			; Jesli nie sa rowne skocz do loop_b
	MOV.B R5,0(R6)			; Zapisz do bufora kolejna liczbe
        MOV.B R8,4(R6)			; w BCD na LSB LCD_buf i LCD_buf+2
	INC R6				; Inkrementacja R6 i R10
	INC R10
	RLAM.A #4,R7			; Przesun bitowo maske o 0xF w lewo
	JMP loop_a                	; Skocz do loop_a
               
display
        MOV     #LCD_buf,R4             ; Zapisz adres LCD_buf do R4
        CLR     R5			; Wyczysc R5
        MOV     #7,R6                   ; Wpisz 7 do R6 (licznik petli)
r_buf   MOV.B   @R4+,R7               	; Odczyt bufora
        MOV.B   LCD_table(R7),LCDMEM(R5); Wyslij kod do LCD
        INC     R5                      ; Inkrementacja R5
        DEC     R6                      ; Dekrementacja R6 (licznik)
        JNZ     r_buf			; Jesli R6!=0 skocz do r_buf
        ; Na podstawie LCD.s43 (prof Janusz Janiczek, kmeif.pwr.edu.pl)

end_programme
        NOP
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
END
